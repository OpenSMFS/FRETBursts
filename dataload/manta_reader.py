# -*- coding: utf-8 -*-
"""
This module contains core functions to read and process timestamps
generated by Manta detector or by NI hardware.
"""

import numpy as np


def load_manta_timestamps(fname, format='xa', debug=False, full_output=False,
                          i_start=0, i_stop=None):
    """Load manta-timestamps data from `fname`.

    Parameters
    ----------
    fname : (string)
        name of the file containing the data
    format : (string)
        Select a data format. Use **raw** for unmodified manta timestamps
        as saved by Luca's VI; **xa** for the format save by Xavier VI.
    debug : (boolean)
        enable additional safety-checks.
    i_start, i_stop : (integers)
        load timestamps between index start and stop (default: load them all)

    Returns
    -------
    timestamps : list of arrays
        each list element is an array of timestamps for one ch.
    big_fifo_full : list of arrays
        each list element is a bool array of big-FIFO-full flags.
    small_fifo_full : list of arrays
        each list element is a bool array of small-FIFO-full flags.
    """
    assert format in ['raw', 'xa']
    if format == 'raw':
        data = load_raw_manta_data(fname, dtype='<u4')
    elif format == 'xa':
        data = load_xavier_manta_data(
                fname, dtype='>u4', i_start=i_start, i_stop=i_stop)
    timestamps, det = get_timestamps_detectors(data, nbits=24)
    timestamps_m, big_ff, small_ff = process_timestamps(
            timestamps, det, fifo_flag=True, debug=debug)
    if full_output:
        return timestamps_m, big_ff, small_ff, timestamps, det
    else:
        return timestamps_m, big_ff, small_ff


def load_ni_timestamps(fname, debug=False):
    """Load from `fname` manta timestamps acquired by NI card.

    Parameters
    ----------
    fname : string
        name of the file containing the data
    debug : boolean
        enable additional safety-checks.

    Returns
    -------
    timestamps : list of arrays
        each list element is an array of timestamps for one ch.
    big_fifo_full : list of arrays
        each list element is a bool array of big-FIFO-full flags.
    small_fifo_full : list of arrays
        each list element is a bool array of small-FIFO-full flags.
    """
    data = load_xavier_manta_data(fname, dtype='>u4')
    timestamps, det = get_timestamps_detectors(data, nbits=24)
    return process_timestamps(timestamps, det, fifo_flag=False, debug=debug)


def load_xavier_manta_data(fname, skip_lines=3, dtype='>u4',
                           i_start=0, i_stop=None):
    """Load manta-timestamps data from `fname` saved from Xavier VI.
    Returns the unprocessed uint32 words containing detector and timestamp.
    """
    f = open(fname, 'rb')
    # Discard a some lines used for header
    for x in range(skip_lines):
        f.readline()
    # Load the rest of the file in buff
    dt = np.dtype(dtype)
    old_pos = f.tell()
    f.seek(f.tell() + dt.itemsize*i_start)
    if i_start == 0:
        assert f.tell() == old_pos
    if i_stop is None: i_stop = -1
    buff = f.read(dt.itemsize*i_stop)
    a = np.ndarray(shape=(len(buff)/dt.itemsize,), dtype=dt, buffer=buff)
    print a.shape
    return a
    #return np.ndarray(shape=(len(buff)/dt.itemsize,), dtype=dt, buffer=buff)

def load_raw_manta_data(fname, dtype='<u4'):
    """Load manta-timestamps data from `fname` saved from Luca's VI.
    Returns the unprocessed uint32 words containing detetctor and timestamp.
    """
    return np.fromfile(fname, dtype=dtype)

def get_timestamps_detectors(data, nbits=24):
    """From raw uint32 words extrac timestamps and detector information.
    Returns two arrays: timestamps (uint32) and detectors (uint8).
    """
    det = np.right_shift(data, nbits) + 1
    timestamps = np.bitwise_and(data,  2**nbits - 1)
    return timestamps, det

def process_timestamps(timestamps, det, delta_rollover=1, nbits=24,
                       fifo_flag=True, debug=False):
    """Process 32bit timestamps to correct rollover and sort channels.

    Parameters
    ----------
    timestamps : array (uint32)
        timestamps to be processes (rollover correction and ch separation)
    det : array (int)
        detector number for each timestamp
    nbits : integer
        number of bits used for the timestamps. Default 24.
    delta_rollover : positive integer
        Sets the minimum negative difference between two consecutive timestamps
        that will be recognized as a rollover. Default 1.
    debug : boolean
        enable additional consistency checks and increase verbosity.

    Returns
    -------
    3 lists of arrays (one per ch) for timestamps (int64), big-FIFO full-flags
    (bool) and small-FIFO full flags (bool).
    """
    cumsum, diff = np.cumsum, np.diff
    max_ts = 2**nbits

    zero_data = (det == 0)
    det = det[-zero_data]
    timestamps = timestamps[-zero_data]

    if fifo_flag:
        full_big_fifo = np.bitwise_and(1, np.right_shift(det,7)).astype(bool)
        full_small_fifo = np.bitwise_and(1, np.right_shift(det,6)).astype(bool)
        det = np.bitwise_and(det, 0x3F)

    if debug :
        for val in range(49, 255):
            assert (det != val).all()

    full_big_fifo_m = []
    full_small_fifo_m = []
    timestamps_m = []
    for CH in range(1, 49):
        mask = (det == CH)
        if mask.sum() >= 3:
            # We need at least 2 valid timestamps and the first is invalid
            times32 = timestamps[mask].astype('int32')
            times64 = (diff(times32) < -delta_rollover).astype('int64')
            cumsum(times64, out=times64)
            times64 *= max_ts
            times64 += times32[1:]
            del times32
        else:
            # Return an array of size 0 for current ch
            times64 = np.zeros(0, dtype='int64')
        timestamps_m.append(times64)
        if fifo_flag:
            full_big_fifo_m.append(full_big_fifo[mask])
            full_small_fifo_m.append(full_small_fifo[mask])

    return timestamps_m, full_big_fifo_m, full_small_fifo_m

